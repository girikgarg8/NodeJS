===Little bit intro about gRPC===

Why many people don't talk about gRPC?

1. Not very beginner friendly, if introduced to people in early career, people will lose interest in web dev
2. Not many people use it
3. It is more useful for organisations with big scale, it may be more suited for companies working at large scale (like Google), but maybe not for BookMyShow, because BookMyShow doesn't have so much traffic that they need to migrate from REST APIs to GRPC.

1. gRPC is compared with other APIs like REST or SOAP.
2. REST is very widely used and accepted.
3. Frameworks like Django and Rails support REST out of the box.

===gRPC

1. Open source RPC system, developed by Google
2. Till now in REST, in order to make an API call, I use the URL of the API, and use the request body params,header etc. In RPC, if we try to make an object call, it looks like an object call.
3. gRPC supports HTTP 2.0

==Let us see some problem with REST 

Introduction to GRPC

==Problems with REST
1. REST APIs exchange data in the form of JSON, but JSON has issues with typechecking, because by default  JSON is not tyoe-checked, the rollNumber key can have 34 as a string or number.
2. Semantic versioning required on API change (We had talked about API versioning earlier)
3.  By default HTTP 1.1 is supported by REST (whereas HTTP 2.0 is faster than HTTP 1.0)
4. Maintenance of client side libraries (like axios for node, some other library for other languages) is cumbersome

==gRPC comes to the rescue 

1. By default HTTP 2.0 support (which is faster than HTTP 1.1)
2. We use protol buffers instead of JSON, so there is a strict API contract
3. Built in code generators, so we don't have to depend upon the client side libraries
4. Inbuilt load balancing
4. Supports unary, server,client and bidirectional streaming
5. Is more secure than REST

gRPC is faster than REST (about 6 or 7 times fast)

How is gRPC faster?

1. Protocol buffer (protobuf) serialises and deserialises data into binary, thus reducing size of messages and also another advantage is that it is type safe
2. Uses HTTP 2.0 (which is faster than HTTP 1.1)
3. It can support streaming
4. Support for load balancing

https://www.cloudflare.com/learning/performance/http2-vs-http1.1/#:~:text=Multiplexing%3A%20HTTP%2F1.1%20loads%20resources,resource%20blocks%20any%20other%20resource. Read this article for more detailed explanation on differcnes between HTTP 2.0 and HTTP 1.1

XML, JSON, and Protocol Buffers are all network interchange formats that are commonly used for data exchange between applications over a network.

XML is a markup language that is widely used for exchanging data between systems, particularly over the internet. It is often used to exchange structured data, such as configuration files, messages, or documents, between different applications or platforms.

JSON (JavaScript Object Notation) is a lightweight data interchange format that is commonly used for exchanging data between web applications and services. It is particularly popular in web development, as it is easy to read and write, and can be parsed natively by most modern web browsers.

Protocol Buffers is a binary serialization format that is used to exchange data between applications. It is often used in high-performance applications where performance is critical, such as in distributed systems or in mobile devices.

===As the size of serialization in protocol buffer is lesser than JSON and XML, hence communication using protocol buffer is faster for communication.

From the documentation: https://protobuf.dev/  Protocol buffers are Google’s language-neutral, platform-neutral, extensible mechanism for serializing structured data – think XML, but smaller, faster, and simpler. You define how you want your data to be structured once, then you can use special generated source code to easily write and read your structured data to and from a variety of data streams and using a variety of languages. 

So basically, using protocol buffers, I can generate the code template in supported languages like C++,Java etc using code generator, so the dependency on client side frameworks is reduced, and I am getting autogenerated code which is maintained by a central organisation Google.

There's one key difference between naming of APIs in REST is resource based (like /restaurants/123), but in gRPC it is more action based (like createTodo or getTodo)

Many a times, what happens is that when we are using some website like Amazon or Google, internaly they are using gRPC APIs, but they expose a REST API (for convenience to users), and an API gateway accepts REST API and converts it to GRPC request

Disadvantages of grPC:

1. Needs lot of setup, even for a small project, learning curve is quite high

Explanation of the code used: In the given code, the second object being passed as an argument to the protoLoader.loadSync() function is an options object that specifies various options for loading a Protocol Buffer definition file (.proto file) using the protoLoader library.

Let's go over each option in the options object:

keepCase: When set to true, it indicates that the field names in the generated JavaScript objects should maintain their original case as defined in the .proto file. If set to false, the field names will be converted to camelCase. For example, if keepCase is set to true, a field named field_name in the .proto file will be represented as field_name in the generated JavaScript object, whereas if keepCase is set to false, it will be represented as fieldName.

longs: This option specifies how to handle long type fields in the generated JavaScript objects. When set to String, it indicates that long fields should be represented as strings in JavaScript, preserving their full precision. If set to Number, long fields will be represented as JavaScript numbers, but this may result in loss of precision for large long values.

enums: This option specifies how to handle enum type fields in the generated JavaScript objects. When set to String, enum fields will be represented as strings in JavaScript, using the string names defined in the .proto file. If set to Number, enum fields will be represented as JavaScript numbers, corresponding to the numeric values defined in the .proto file.

defaults: When set to true, it indicates that default values defined in the .proto file should be included in the generated JavaScript objects. If set to false, default values will be omitted from the generated objects.

oneofs: When set to true, it indicates that oneof fields in the .proto file should be represented as JavaScript objects with the field names as keys, even if only one of the fields in the oneof group is set. If set to false, only the set field in the oneof group will be represented in the generated JavaScript object.