====Intro to closures and callbacks video====

We are going to use setTimeout and setInterval functions for code demonstration.

setTimeout and setInterval are not functions defined by Javascript, as they are not present in the official ECMAScript documentation. But we are able to access these functions. 

How are we still able to access these functions? Will be answered in some lectures.

setTimeout is a function that helps to execute some task once after a certain timer

setInterval: It is a function that helps us to execute some task again and again after a given interval. (Example: there could be a usecase, where I want to check database periodically after some interval)

===What is a bacllback function===

Callback function is a function passed as an argument to another function, which is then invoked (called) inside the outer function to complete some kind of action or routinue, in mathematical terms it's f(g(x))

Arguments vs parameters? Argument is what the function expects, like fun(x) expects an argument but when we call fun(5), we are passing 5 as the parameter.

Callback is not just a concept in Javascript, even in languages like C++, we can pass a function to another function, using function pointers.

arr.mp(fn): it passes all the elements (one-by-one) of the given array as argument to the callback function.

Also, arr.map returns an array after calculating the results for all the arguments passed as arguments. See the code examples file to understand better. map function never modifies the original array.

Let's try to create a custom mapper funtion, which is a polyfill for map function in Javascript. Important interview question.

setTimeout(callbackTask,timeInMilliseconds)

Real life Use case of setTimeout function: in notyjs notifications, the popup appears for a particular time duration, and after that, the notification disappears

====Promises and callback Lecture====

Concept of closures: Technically, closures is a result of scoping mechanism in Javacript. Let's try to understand what is closure, with the help of code snippet in closure_demo1.js

The thing to wonder about in this code is that: the function fun is getting called after the function todo has already finsihed executing, so how is it able to access the task property from the function todo, even though the function todo has stopped executing? The answer lies in closures. 

See the image attached: https://drive.google.com/open?id=1sneg74yD_2jrAXjYJYeSbor7fbr045eh

This happens due to closures.

Closure is when a function remembers its lexical scope,(remembering lexical scope means whatever variables and functions were accessible in the lexical scope of that function) even htough the function may be execited outside of that lexical scope.

So, in the given example,the function fun is in the scope of function todo, and the function fun is executed outside the scope of todo.

How does scope resolution work in the above code example? 

the function todo is getting assigned the global scope, and the function fun is getting assigned the scope of function todo. Now by the property of closures, the function fun remembers its lexical scope (todo), so even though the function 'todo' may be called outside of the scope of function todo, it will still have access to the variables or functions (data members) defined in the lexical scope i.e. the scope of todo.

It;s important that todo is not getting snapshotted, we are not storing the value of variable, we are just remebering the lexical scope (i.e. the enclosing scope) (will be clear from the code examples, see demo1.js file)

One more thing to note here is that, (for example in the code snippet of demo1.js file), the variable todo from 'task' is not getting vanished after function execution, if there's a function which has closure with the outside scope, it will be able to access that variable from the lexical scope.


===Async nature of JS Lecture===

How JS handles async operations? (This is a very practical aspect of JS)

Languages like Java,C++ are multithreaded but Javascript is single-threaded.

Let's understand about async operations in real life applications:

1. Let's say I have built a Swiggy like app on Javascript, and I am using payment services from Razorpay, then I need to make an API call to Razorpay, let's say it takes 2 seconds to make an API call, so during these 2 seconds, should the app freeze? No, that's a very bad user experience

2. Let's say I am designing facebook like app on JS, and I hit the like button on a post, then I need to make a call to make the changes in the database as well, let's say it takes 3 seconds, again I can't let the app freeze, that would be a very bad experience. 


Javascript, by default, supports only synchronous code execution. (What I mean by synchornous is that: if there are 5 lines of code to be executed, and the 4th line of code requires me to wait 5 seconds, I will wait for 5 seconds and then move to the next line of code ) (See the sync_code_demo.js file)

IMPOTRTANT NOTE: Thr property of by default synchronous code execution works only for operations (like for loop, while loop etc but not setTimeout, setTimeout is not provided by the javascript, it is provided by browser) which are known to Javacript.


Let's talk about JS runtime environment: So, initially Jaavscript was intended to be used only on browsers, and browsers provided the JS runtime environment. In a layman term, I can say that JS alone is very weak, many of the powers to the JS come through the JS runtime environment. In the case of browsers, the browser provides access to Web APIs like DOM APIs (for example the document.getElementById is provided by the browser, it is not provided by Javascript itself), setTimeout, set Interval etc

one more important thing: JS engine is a component of JS runtime environment,so don't confuse between JS runtime environment and JS engine.

However, in 2009, the inventor of NodeJS (Ryan Dahl, need not to cram his name :P), used a runtime environment for JS, which was not the browser, and using this runtime environment, he got access to the file system (file handling with hard disk which we do in other languages too), process (the environment variable process which we have access to), and setTimeout (setTimeout in this case is provided by the OS functionality)


See these diagrams: https://drive.google.com/open?id=1W6qaAnI4abgMSIrdToLhwNj-Z-zHbasU
and https://drive.google.com/open?id=1Up42sbdCYnooqEADFVe7_e_OZt8BAlMM

Just a side note: When I execute the code using 'code runner' in VS Code, it actualy executes the command 'node index.js', so I am running the file inside Node runtime environment.

So, now we know that runtime also provides functionalities that can be leveraged by JS. But how does JS handle them? 

Now the question that arises: we can easily do tasks that take a lot of time to complete without blocking the code flow. How??

Let's understand with the code example from code_example.js file

Explantion of the code from that file: First of all, the global execution context is pushed into the call stack, (global execution stack is just a fancy name for the global scope code), and thereafter the process function is called (so it is pushed into the call stack), now the function process is executing, it will print "Start", when it sees the line setTimeout, it asks the runtime environment (NodeJS or browser), to  execute the code (Since core JS doesn't know how to execute setTimeout), and the core JS, goes to the for loop to execute. 

Now let us suppose that the for loop takes 8 seconds to execute, meanwhile at the end of 3 seconds, the timer would execute, so the runtime environment would tell the JS that the function execution hasd completed, but still JS wouldn't bother about it, (just like we don't listen to our mothers sometime :P), so the runtime environment would push the timer into the event queue.

Now the events are picked from the event queue, only when the call stack is completely empty, i.e. evene the global execution event is also not present inside the call stack.

See the attached diagram for the diagrammatic explanation of the concept: https://drive.google.com/open?id=1PXn_yHQg26KG-K4TDjADP-N3aUTfKKhv


Left at 1:01:03