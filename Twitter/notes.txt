There can be combinatin of different types of databases used in any company.

Just a side note:

===Error first callback===
Error-First Callback in Node.js is a function which either returns an error object or any successful data returned by the function.

The first argument in the function is reserved for the error object. If any error has occurred during the execution of the function, it will be returned by the first argument.
The second argument of the callback function is reserved for any successful data returned by the function. If no error occurred then the error object will be set to null.

for example, while using file system in nodejs, it takes error first callback

const fs = require("fs");


==Taking back the discussion to databases===

No kind of database (SQL or NoSQL) is perfect for all use cases.

What are NoSQL databases? Nosql databases store data in non-tabular form, such as documents, key-value pairs or graph.

MongoDB stores the data in form of JSON like documents.

For general knowledge: PostgreSQL stores the database entries in the form of json objects (not json-like, it's actual json)

In which use case should we prefer SQL over NoSQL systems? Will be discussed in detail, for now, one point is that NoSQL databases are suited for horizontal scaling and distributed systems? The reason which ChatGPT gives is:

SQL databases can be used for horizontal scaling, but they are not as well-suited for this task as NoSQL databases. The main reason for this is that SQL databases are typically designed to run on a single server and handle vertical scaling (scaling up by adding more resources to a single server), rather than horizontal scaling (scaling out by adding more servers to a distributed system).

One of the main challenges with scaling SQL databases horizontally is maintaining data consistency across multiple nodes. With a distributed system, multiple copies of the data may exist on different servers, which can lead to issues with data consistency and concurrency control. Ensuring that all nodes have access to the same data, and that updates to the data are properly synchronized, can be a complex and challenging task.

Another challenge with scaling SQL databases horizontally is that traditional SQL queries are optimized for single-server databases, and may not perform as well when run across multiple nodes. This can lead to performance issues and slow query times as the system scales out.

Overall, while it is possible to scale SQL databases horizontally, NoSQL databases are generally considered to be a better fit for this task due to their distributed architecture, flexible data model, and eventual consistency approach.

MongoDB community edition is the CLI for using MongoDB.
MongoDB compass is a GUI for MongoDB.

Tables in SQL==>Collections  in MongoDB
Rows in SQL=>Documents in MongoDB


In order to interact with mongoose, we will use object document model (ODM) called mongoose, just like we were using ORM to interact with MySQL database.
We use ODM because we don't want to write raw mongoose queries.

Mongoose is specific to nodejs only, means to say it is a ODM which is specific to nodejs only

Sequelise manages the connections automatically,but in case of mongoose we have to define the connection ourselves

Why is there a need of defining a schema in case of MongoDB? In relational databases, schema is necessary because every attribute is required in each row, but in NoSQL databases, defining all the attributes like name, phone number is not necessary in each document, but the use of schema is to make sure that there's consistent object sharing between different communication applications, like for example if I am communicating with database, then I would be atleast sure that what fields I can expect as response

In MongoDB, in order to use time stamps like createdAt and updatedAt, I can specify timestamps:true in the model, MongoDB will automaticaly insert the updatedAt and createdAt timestamps

Unless and until we don't create the first document(row) in the collection(table), ntil then the model will not be created in MongoDB


In a MongoDB schema, id and __v are two commonly used fields:

id: This field is automatically added to every MongoDB document as a unique identifier. It is a 12-byte hexadecimal string that is generated by MongoDB when a new document is inserted. You can also specify your own value for this field when inserting new documents.
For example, suppose we have a users collection, and we insert a new document with the following data:

json
Copy code
{
  "_id": "6051b8a360a46f16b356f0c1",
  "name": "Alice",
  "age": 30
}
In this case, the _id field is set to the value "6051b8a360a46f16b356f0c1". This value is unique to this document and can be used to retrieve or update it later.

__v: This field is used by Mongoose, a popular MongoDB library for Node.js, to track the version of a document. It is an integer value that starts at 0 and is incremented every time the document is updated.
For example, suppose we have a posts collection, and we insert a new document with the following data:


{
  "title": "My first post",
  "content": "This is my first post on this blog"
}
In this case, the __v field is not specified, so it is automatically set to 0. If we update this document later, the __v field will be incremented:


{
  "_id": "6051b8a360a46f16b356f0c2",
  "title": "My first post",
  "content": "This is an updated version of my first post",
  "__v": 1
}
In this case, the __v field has been incremented to 1 to indicate that this is a newer version of the document.

Overall, the id field is used as a unique identifier for each document, while the __v field is used by Mongoose to track the version of a document.

By default, when I execute a find and update query, it will update the document but it will return the old document (before updation), to return the new document I can specify new:true in the options

Some awesome stuffs about NoSQL database:

1) I can keep the attributes as object, like comments atribute can be an object, it is not possible while using relational databases
2) NoSQL databases are easy to start with, in a project
3) The structure of the table need not to be known at the beginning of the project, it can be updated on the fly

1:28:24



